---
title: "Aprendizado Supervisionado"
---

```{r, message=FALSE, warning=FALSE, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE, 
  out.width = "50%", out.height = "50%",
  fig.retina = 2
)
```

## Aprendizado Supervisionado

Suponha que você observou uma variável resposta $Y$ e $p$ diferentes variáveis 
explicativas $X_1, X_2, ..., X_p$. Assumimos que existe alguma relação entre $Y$
e $X = (X_1, X_2, ..., X_p)$. Podemos denotar matematicamente esta relação como
na seguinte equação:

$$Y = f(X) + \epsilon$$

O objetivo geral do aprendizado supervisionado é estimar a função $f$.
Nessa formulação, $\epsilon$ é um termo de erro aleatório com média 0. $f$ representa
a informação sistemática que $X$ fornece sobre $Y$.

### Modelos lineares

O modelo linear assume que a função $f$ é uma função linear de modo que a formulação
do apredizado supervisionado pode ser reescrita da seguinte forma:

$$Y = \alpha + X\beta + \epsilon$$
Em que $\alpha$ e $\beta$ são coeficientes que serão estimados. Esses valores são 
calculados de forma a minimizar uma **função de perda** na sua amostra. A função 
mais utilizada é a perda quadrática na sua amostra. Considere $(y_1, x_1)$, $(y_2, x_2)$, ..., $(y_n, x_n)$ uma amostra de tamanho $n$.

$\alpha$ e $\beta$ são escolhidos de tal forma que:

$$\sum_{i = 1}^{n} [y_i - (\alpha + \beta x_i)]^2$$
seja o menor possível. Isto é, estamos minimizando o *erro quadrático*.

Na ótica da estatística, assumimos também que $Y \sim Normal(\alpha + X \beta, \sigma^2)$, 
escolhemos $\alpha$ e $\beta$ de forma que maximize uma função que chamamos de [verossimilhança](https://pt.wikipedia.org/wiki/Fun%C3%A7%C3%A3o_de_verossimilhan%C3%A7a). 
Essa suposição é útil quando queremos fazer testes de hipóteses e intervalos de 
confiança. Por enquanto, não estamos interessados nisso e portanto vamos 
apresentar uma visão menos complexa.

#### Exemplo

Considere o banco de dados *BodyFat* obtido [aqui](http://www2.stetson.edu/~jrasp/data.htm). 
Esses são dados do percentual de gordura corporal em uma amostra de 252 homens junto com
diversas outras medidas corporais. O percentual de gordura corporal é medido pesando
a pessoa sob a água, um procedimento trabalhoso. O objetivo é fazer um modelo linear
que permita obter o percentual de gordura usando medidas do corpo fáceis de serem obtidas.
Os dados são do site do Journal of Statistics Education.

```{r, message=FALSE, warning=FALSE}
library(readxl)
library(dplyr)
library(ggplot2)
bodyfat <- read_excel('data/BodyFat.xls')
```

```{r}
ggplot(bodyfat, aes(x = WEIGHT, y = BODYFAT)) + geom_point()
```

A partir do gráfico de dispersão, vemos que o peso do indivíduo parece ser **linearmente**
relacionado ao percentual de gordura corporal. Vamos então ajustar um modelo linear
usando o R. Para ajustar o modelo, usamos a função `lm` (de *__l__inear __m__odel*). 
A função `lm`, assim como muitas outras que ajustam modelo no R, recebe como argumentos
uma formula e um banco de dados. 

`formula` é um tipo especial de objeto no R que ajuda muito na especificação dos modelos. 
Ela tem a forma `y ~ x1 + x2 + ... + xn` em que `y` é o nome da variável resposta e `x1`,
`x2`, ..., `xn` são os nomes das variáveis que serão utilizadas como explicativas. 

```{r}
ajuste <- lm(BODYFAT ~ WEIGHT, data = bodyfat)
```

Com essa chamada da função criamos o objeto `ajuste`. Esse objeto abriga informações
relacionadas ao ajuste do modelo.

$$bodyfat = \alpha + \beta*weight + \epsilon$$
As estimativas de $\alpha$ e $\beta$ podem ser encontradas usando a função `summary`.
A estimativa de $\alpha$ é o valor da coluna `Estimate` na linha `(Intercept)`: -9.99515 
e a estimativa de $\beta$ é o valor logo abaixo: 0.16171.

```{r}
summary(ajuste)
```

Em R, o ajuste de um modelo estatístico é salvo em um objeto. Esse objeto é uma
`list` que armazena diversas informações sobre o ajuste. Você pode ver algumas
informações disponíveis quando vê a estrutura do objeto `ajuste` usando a função 
`str`.

```{r}
str(ajuste, max.level = 1)
```

Por exemplo você pode acessar os coeficientes do modelo usando `ajuste$coefficients`.

Outra função que existe para a maior parte dos modelos que podem ser ajustados usando o R 
a `predict`. Usamos a função `predict` para obter as estimativas do modelo ajustado para
uma base de dados (nova ou não).

```{r}
bodyfat$predito_modelo1 <- predict(ajuste, newdata = bodyfat)
bodyfat %>% select(WEIGHT, BODYFAT, predito_modelo1) %>% head() %>% knitr::kable()
```

Nessa tabela, vemos o valor predito pelo modelo para cada observação bem como o
valor verdadeiro de gordura corporal daquele indivíduo. Nosso modelo não parece
estar muito bom. Uma possível medida de erro é o MSE (Erro quadrático médio).
Podemos calculá-lo fazendo contas simples no R.

```{r}
mse <- mean((bodyfat$BODYFAT - bodyfat$predito_modelo1)^2)
mse
```

É mais fácil identificar se esse erro é baixo ou não comparando-o com o erro se 
usássemos a média da variável como valor predito para todas as observações e 
tirando a raíz quadrada dos dois.

```{r}
erro_usando_media <- mean((bodyfat$BODYFAT - mean(bodyfat$BODYFAT))^2)
erro_usando_media

sqrt(mse)
sqrt(erro_usando_media)
```

Agora podemos ter uma ideia de que o nosso erro está alto. Se usássemos apenas a 
média erraríamos em média 7,7 usando o nosso modelo, ficamos com 6,1.

Felizmente, podemos melhorar o modelo adicionando mais variáveis. No R basta:

```{r}
ajuste2 <- lm(BODYFAT ~ WEIGHT + HEIGHT + CHEST + ABDOMEN + NECK + KNEE, 
              data = bodyfat)
```

O erro pode ser novamente calculado repetindo as operações que fizemos anteriormente.

```{r}
bodyfat$predito_modelo2 <- predict(ajuste2, newdata = bodyfat)
mse <- mean((bodyfat$BODYFAT - bodyfat$predito_modelo2)^2)
sqrt(mse)
```

Agora reduzimos bastante o erro. É muito importante ressaltar que estamos avaliando
o erro dentro da mesma base de dados que utilizamos para ajustar o modelo. Isso é 
considerado uma má prática, pois podemos facilmente esbarrar em uma situação de
*superajuste* ou *overfitting*.

----------------

Até agora vimos que usando a função `lm` podemos ajustar um modelo linear usando o
R. Esse único comando, que recebe um formula e um banco de dados, retorna um objeto 
que é similar a uma `list` e que armazena uma variedade de informações sobre o 
ajuste como coeficientes, dados utilizados, etc. Aprendemos também a função `summary`, 
que "imprime" no console uma série de informações sobre o ajuste. Também vimos a 
função `predict` que é utilizada pra obter os valores preditos pelo modelo para 
uma nova base de dados.

Mais tarde falaremos novamente sobre modelos lineares quando falarmos sobre 
[regressão logística](https://pt.wikipedia.org/wiki/Regress%C3%A3o_log%C3%ADstica).

### Árvore  de Decisão

Os modelos de árvore de decisão como vamos utilizar são implementados de acordo
com o livro *Classification and Regression Trees* de Breiman, Friedman, Olshen e Stone.
No R, o pacote que usamos para fazer este tipo de análise é o `rpart`. Uma 
curiosidade é que gostariam que os autores do pacote gostariam de usar o nome `cart`,
mas esse nome foi utilizado por uma implementação particular dessas ideias. No fim,
ficou mais famoso o `rpart`, mostrando a importância do software livre.

Não vamos entrar matematicamente no detalhe de como funciona uma árvore de decisão.
Para entender como funciona um árvore de decisão, imagine que você tem um nó com
$N$ observações e que $n$ possuem $Resposta = 1$ e $N - n$ possuem $Resposta = 0$, 
ou seja, temos um problema de classificação binária. Então neste caso $p = \frac{n}{N}$
é a proporção de resposta neste nó.

O objetivo da árvore de decisão dividir este nó em 2 de forma que a diferença entre
a proporção de respostas entre os dois nós resultantes seja a maior possível. Claro que 
cada um dos nós precisa ter uma quantidade significativa de observações de forma que $p$ 
seja estimado corretamente.

Uma introdução mais formal a esses métodos pode ser encontrada na vignette do pacote 
`rpart`. Digite `vignette('longintro', package = 'rpart')` no console para encontrá-la.

### Exemplo 

Para esse exemplo vamos usar o banco de dados do Titanic. Um banco de dados que
ficou famoso por causa de uma competição no Kaggle. Esse banco de dados contém 
diversas informações sobre os passageiros do Titanic bem como uma variável que 
indica se o passageiro sobreviveu (1) e se não sobreviveu (0).

```{r, warning=FALSE}
library(readr)
titanic <- read_csv('data/titanic-train.csv')
titanic$Survived <- as.factor(titanic$Survived)
```

Usando o `rpart` podemos ajustar o modelo de árvore de cdecisão fazendo.
A função `rpart` recebe uma fórmula indicando a variável resposta e as 
variáveis que serão utilizadas no modelo, além de receber um argumento
`data` que indica o banco de dados utilizado.

```{r}
library(rpart)
arvore <- rpart(Survived ~ Sex + Age + Pclass, data = titanic)
```

Assim como na regressão linear, podemos ver informações sobre o ajuste
usando a função `summary`.

```{r}
summary(arvore)
```

Visualizar a árvore de decisão sempre dá bons *insights*. Um pacote que é interessante
para visualizar a árvore de decisão construída com o `rpart` é o `rpart.plot`. 

```{r, out.width = '70%', out.height = '70%'}
library(rpart.plot)
rpart.plot(arvore)
```

A visualização é bem intuitiva. No topo, vemos o primeiro nó em que 38% dos indivíduos
sobreviveram e que representa o total da base (100%). Em seguida, vemos que a primeira
variável que discrimina quem sobreviveu ou não é a variável Sexo: Dos homens, que eram 65%
dos passageiros, apenas 19% sobreviveu enquanto das mulheres, que eram 35%, 74% sobreviveu.
Dos homens, aqueles que eram menores de 6 anos e meio, sobreviveram em maior proporção
também. A interpretação pode continuar dessa forma recursivamente.

Mais uma vez, assim como na regressão linear, podemos utilizar a função `predict` para 
obter a probabilidade predita de sobrevivência e a classificação predita para cada
observação. A diferença é que agora temos o parâmetros `type`, que vai indicar se queremos
a probabilidade ou a classe predita.

```{r}
probabilidades <- predict(arvore, newdata = titanic, type = 'prob')
```

Com `type = 'prob'` obtemos uma `matrix` em que cada coluna representa a probabilidade
predita para cada classe. Quando temos apenas um classe isso pode parecer desnecessário
já que o valor de uma coluna é a diferença de 1 pelo valor da outra, mas árvores podem 
ser utilizadas em modelos com mais de classificação para mais de duas categorias.

```{r}
classes <- predict(arvore, newdata = titanic, type = 'class')
```

Quando você prevê a classe diretamente, o `rpart` indica como predito quando a
probabilidade de sobrevivência é maior do que 50%. Isso nem sempre é o que garante
o maior ganho com o modelo. Principalmente em problemas em que as classes são muito
desbalanceadas. Além disso, em outros problemas, os custos de classificar uma observação
como positiva quando ela é negativa, podem ser diferentes de classificá-la como negativa
quando ela é positiva.

Para escolher o melhor ponto de corte da probabilidade, podemos usar a curva ROC, e
uma função de custo. Existem diversos pacotes que ajudam a calcular essas medidas. Vamos fazer aqui sem usá-los para praticar.

```{r}
library(tidyverse)
cortes <- seq(0,1,by = 0.01)
valores <- map_df(cortes, function(x){
  tabela <- table(
    titanic$Survived, 
    factor(probabilidades[,2] > x, levels = c("FALSE", "TRUE"))
    )
  data_frame(
    corte = x,
    FPR = tabela[1,2]/sum(tabela[1,]),
    TPR = tabela[2,2]/sum(tabela[2,]),
    TNR = tabela[1,1]/sum(tabela[1,]),
    FNR = tabela[2,1]/sum(tabela[2,])
  )
})


ggplot(valores, aes(x = FPR, y = TPR)) + 
  geom_step() + 
  geom_abline(color = 'blue', linetype = 'dashed')
```

A função de custo pode ser calculada da seguinte forma. Veja que estamos considerando
pesos iguais para ambos os erros.

```{r}
valores %>%
  mutate(custo = FPR + FNR) %>%
  ggplot(aes(x = corte, y = custo)) +
  geom_line()
```

Neste caso, o ponto mínimo da função é obtido com qualquer corte entre um pouco menos de 25%
até um pouco mais de 50%. Isso nem sempre é verdade e deve ser avaliado em cada modelo.



